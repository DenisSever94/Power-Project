# My devtools project
[![Java CI with Checkstyle and JaCoCo](https://github.com/DenisSever94/Devtools-Project/actions/workflows/ci.yml/badge.svg)](https://github.com/DenisSever94/Devtools-Project/actions/workflows/ci.yml)
# Practice Project

# Quick start:

### Через Gradle Tool Window:
Откройте в правой части IDEA вкладку Gradle 
(или Tool View -> Tool Windows -> Gradle)
Разверните дерево проекта devtools -> Task 
Дважды щелкните по нужной задаче:
- **build** -> полная сборка проекта (компиляция, тесты, создание JAR)
- **test** -> запуск всех модульных тестов
- **run** -> запуск основного класса application

### Через Run Anything
- **Нажмите** -> Ctrl + Ctrl дважды в любой части IDE
- **В появившемся окне** введите имя задачи (build, test, run) и нажмите Enter
- **IDEA** выполнит задачу автоматически отрыв окно выполнения
- **Для задачи run** можно использовать зеленую стрелочку рядом ▶️ с объявлением сновного класса и методом main

### Packages
- **Структура пакетов организована по доменному принципу для обеспечения четкой логической организации кода:**
- **ru.mentee.power** корневой пакет проекта

### Table variables
- **String menteeName** Имя ученика работающим над задачами
- **int sprintNumber** Номер текущего спринта 
- **int plannedHoursPerWeek** Количество часов запланированных на рабочую неделю

### Правило readyForSprint()
- **Ученик готов** если количество часов >= 3

### Правило веток
- **master** основная ветка. В нее сливаются только проверенные изменения
- **feature/DVT-X** ветка для разработки новой функциональности, где 'X' это номер задачи

- **Examples:**
- 'master'- стабильная ветка по умолчанию
- 'feature/DVT-3'- ветка для разработки задачи DVT-3

## Сценарий ручной проверки DVT-6

### Запуск приложения
1. Откройте Gradle Tool Window (View → Tool Windows → Gradle)
2. Выполните: devtools → Tasks → application → run
3. Ожидаемый вывод в Run Tool Window:
   Суммарно: пройдено 25 из 36 уроков, осталось 11 уроков

### Запуск тестов
1. Откройте Gradle Tool Window
2. Выполните: devtools → Tasks → verification → test
3. Ожидаемый вывод: BUILD SUCCESSFUL, все тесты зелёные

### Отладка через Debug
1. Установите breakpoint на строке цикла while в ProgressTracker.calculateProgress
2. Запустите Debug: кликните правой кнопкой на main → Debug 'ProgressTracker.main()'
3. Используйте Step Over (F8) для прохождения итераций
4. Проверьте Variables: counter, remainingHours должны изменяться корректно
5. Используйте Evaluate Expression (Alt+F8): вычислите remainingLessons * 2
6. Ожидаемый результат Evaluate: 14 (для completedLessons=5, totalLessons=12)

### Что делать при ошибках
- Если вывод некорректен: проверьте логику цикла через Debug
- Если тесты красные: откройте вывод теста, найдите AssertionError, скорректируйте метод
- Если Debug не останавливается: убедитесь, что breakpoint установлен (красный кружок)

## Кодстайл-гайд проекта devtools

Проект следует правилам Google Java Style Guide с адаптацией.
Автоматическая проверка: ./gradlew checkstyleMain

### 1. Именование методов: camelCase

До:    public void add_student(Student s) { }
После: public void addStudent(Student student) { }

Почему: Java Convention требует camelCase для методов.
Источник: https://google.github.io/styleguide/javaguide.html#s5.3-camel-case

### 2. Пробелы после if/for/while

До:    if(condition) {
После: if (condition) {

Почему: улучшает читаемость, отделяет ключевое слово от выражения.
Источник: Oracle Code Conventions — Whitespace

### 3. Длина строки: максимум 120 символов

До:    public List getStudentsFromSpecificCityWithVeryLongName...
После: public List getStudentsByCity(String city) {

Почему: длинные строки затрудняют чтение в редакторе и при code review.
Источник: https://google.github.io/styleguide/javaguide.html#s4.4-column-limit

### 4. Порядок импортов

До: 
import java.util.List; 
import java.util.ArrayList; 
import java.io.File;

После:
import java.io.File;
import java.util.ArrayList;
import java.util.List;

Почему: алфавитный порядок упрощает поиск импортов.
Источник: IntelliJ IDEA → Code → Optimize Imports

### 5. Фигурные скобки для if

До:    if (condition) doSomething();
После: if (condition) { doSomething(); }

Почему: скобки обязательны даже для однострочных блоков.
Источник: https://google.github.io/styleguide/javaguide.html#s4.1.1-braces-always-used

## Code Review Checklist

Используйте этот чеклист для само-ревью перед запросом ревью у ментора:

### Функциональность
- [ ] Код решает поставленную задачу полностью
- [ ] Обработаны граничные случаи (null, пустые данные, экстремальные значения)
- [ ] Обработка ошибок реализована корректно

### Тесты
- [ ] Добавлены тесты для нового функционала (или обновлены существующие)
- [ ] Все тесты проходят локально: `./gradlew test`
- [ ] Покрыты позитивные и негативные сценарии
- [ ] JaCoCo coverage ≥ 80% для нового кода

### Читаемость и стиль
- [ ] Имена переменных, методов и классов отражают назначение
- [ ] Нет дублирования кода (DRY principle)
- [ ] Checkstyle проходит без ошибок: `./gradlew checkstyleMain`
- [ ] Нет закомментированного кода или отладочного вывода (`System.out.println`)

### Документация
- [ ] README обновлён (если добавлена новая функциональность)
- [ ] Публичные методы имеют JavaDoc (если применимо)
- [ ] Примеры использования актуальны
- [ ] Runbook обновлён (если изменились команды запуска/проверки)

### Производительность и безопасность
- [ ] Нет очевидных проблем производительности
- [ ] Нет хардкода паролей, токенов или конфиденциальных данных

## Примеры Code Review комментариев

### Хорошие комментарии (конструктивные)

**Пример 1:**

**Проблема:** Метод `calculateDiscount` (строка 45) имеет 3 вложенных if-else и 40 строк.
**Почему это важно:** Сложная логика плохо тестируется и тяжело поддерживается.
**Предложение:** Вынести каждое условие в отдельный метод (например, `isEligibleForBonusDiscount()`)
и использовать паттерн Strategy для разных типов скидок.



**Пример 2:**

**Проблема:** Тест `testProcessOrder` (строка 78) проверяет только успешный сценарий.
**Почему это важно:** Не проверена обработка ошибок при недостаточном балансе.
**Предложение:** Добавить тест `testProcessOrder_InsufficientBalance_ThrowsException()`
с использованием `assertThatThrownBy()`.



### Плохие комментарии (неконструктивные)

**Пример 1:**

Этот код ужасен, полностью переписать.


**Почему плохо:** Нет конкретики (что именно плохо), нет предложения (как исправить),
токсичный тон (демотивирует автора).

**Пример 2:**

Здесь лучше использовать Stream API.


**Почему плохо:** Нет объяснения почему лучше, нет примера как переписать,
неясно какую проблему это решает.


## Результаты само-ревью DVT-9

### Найдено и исправлено проблем: 3

#### 1. Проблема в классе StudentList нет метода для поиска студента по имени
**Файл** src/main/java/ru/mentee/power/devtools/student/StudentList.java 

**Суть** есть метод для поиска студента по городу, но нет по имени

**Почему важно** Пользователь может найти студента по имени 

**Как исправить** предлагаю реализовать метод для поиска по имению findStudentByName


#### 2. Нейминг studentList
**Файл** src/main/java/ru/mentee/power/devtools/student/StudentList.java 

**Суть** название переменной в строке 8 "studentList" может быть избыточным так как и класс называется StudentList

**Как исправить** предлагаю переименовать в "students", так будет понятней, что это список студентов и никак не будут
пересекаться с названием класса.


#### 3. Нейминг метода getStudent 
**Файл** src/main/java/ru/mentee/power/devtools/student/StudentList.java 

**Суть** название метода в целом рабочее, но для читабельности и более точного понимания, что делает метод,
а метод именно ищет студента в списке students, предлагаю переименовать на findStudentByCity.

#### Формат сообщения сдачи в Telegram 

- DVT-9: Правила Code Review
- Репозиторий: ССЫЛКА
- Pull Request: ССЫЛКА
- Статус: готова
- 
  @dev_tools


## Информационный поиск — результаты DVT-11

### Запросы и источники

| № | Запрос               | Операторы                                                    | Официальный источник                                                                                                                                        | Альтернатива                                                       | Статус | Дата проверки |
|---|----------------------|--------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|--------|---------------|
| 1 | Lombok Gradle Short  | site:search.maven.org "lombok" OR site:mvnrepository.com "lombok" | https://central.sonatype.com/artifact/org.projectlombok/lombok/1.18.42/overview                                                                             | https://mvnrepository.com/artifact/org.projectlombok/lombok/1.18.42 | 200 OK | 10.01.2026    |
| 2 | Stream Api           | site:docs.oracle.com "stream api" intitle:api java 25        | https://docs.oracle.com/en/middleware/standalone/coherence/15.1.1/develop-applications/using-repository-api.html#GUID-6FE2A09E-71FF-4D65-AB04-972B95BA87D6  | https://www.jetbrains.com/help/inspectopedia/Convert2streamapi.html | 200 OK | 10.01.2026    |
| 3 | keymap intellij idea | site:jetbrains.com/help "keymap intellij idea"               |https://www.jetbrains.com/help/idea/settings-keymap.html  | https://woori.studio/wp-content/uploads/2017/01/intellijidea_referencecard_mac.pdf | 200 OK | 10.01.2026    |

### AI-промпты и сравнение ассистентов

#### Промпт 1: План решения
**Роль** ты java senior developer с 10 годами опыта.
**Задача:** Мне нужно добавить метод для сортировки по имени в алфавитном порядке в класс Student с полем name.
**Контекст:** Java 25, проект на gradlew, SOLID.
**Ограничения:** не использовать stream api, учти что может быть несколько одинаковых имен.
**Ожидаемый результат:** план из 3-5 шагов, объяснение "почему именно так", НЕ пиши код — я реализую сам
**Критерии успеха:** План конкретный и последовательный, каждый шаг — четкое действие.

**AI-1 ([DeepSeek]):**

План реализации метода сортировки студентов по имени:

Добавить метод сравнения в класс Student:

Реализовать интерфейс Comparable<Student> с методом compareTo().

Почему: Это стандартный Java-подход для естественного порядка сортировки объектов. Позволит использовать Collections.sort() без передачи компаратора каждый раз. Учитываем, что имена могут повторяться, поэтому порядок одинаковых имен не важен — можно возвращать 0.

Переопределить equals() и hashCode() для согласованности:

Обновить методы, чтобы они учитывали только поле name или все поля (в зависимости от бизнес-логики).

Почему: При реализации Comparable рекомендуется соблюдать контракт: compareTo() должен быть согласован с equals(). Это предотвратит противоречивое поведение в коллекциях.

Добавить статический компаратор в Student:

Создать public static final Comparator<Student> NAME_COMPARATOR с лямбдой или анонимным классом.

Почему: Предоставит гибкость для сортировки только по имени без учета других полей. Соответствует SOLID (принцип единственной ответственности — класс отвечает и за свои данные, и за логику их сравнения).

Протестировать сортировку в отдельном классе:

Создать список студентов с дубликатами имен и разными данными.

Проверить сортировку через Collections.sort(list) и Collections.sort(list, Student.NAME_COMPARATOR).

Почему: Убедимся, что сортировка работает корректно с повторяющимися именами, не ломает существующий код и соответствует контрактам.

Обновить документацию:

Добавить JavaDoc к методу compareTo() и компаратору, указав, что сортировка идет по алфавиту и одинаковые имена считаются равными.

Почему: Это улучшит читаемость кода и поможет другим разработчикам правильно использовать функциональность без изучения реализации.

Ключевые моменты для реализации:

Использовать String.compareTo() для сравнения имен.

При дубликатах имен возвращать 0 (или сравнивать по дополнительному полю, например ID, если требуется уникальность — но по ТЗ это не нужно).

Учесть регистр букв: String.compareTo() чувствителен к регистру. Если нужна регистронезависимая сортировка, используйте String.compareToIgnoreCase().

Gradle сборка не требует изменений, так как меняется только исходный код.



**AI-2 ([ChatGPT]):**

Добавить локаль- и null-безопасный Comparator в класс Student (или сделать public static константу Comparator).

Правила сравнения: null-элементы списка и/или null-имена обрабатываются предсказуемо (например, null имя считается «больше» ненулевого — чтобы такие записи шли в конец).

Использовать Collator (или эквивалент) для корректной алфавитной сортировки с учётом локали и регистра; настроить силу сравнения так, чтобы, при необходимости, регистр не влиял.

Добавить в Student вспомогательный метод-сортировщик, который сортирует список на месте (in-place) с использованием этого Comparator, без Stream API.

Метод должен принимать List<Student> и валидировать аргументы (null-check).

Использовать стандартный алгоритм сортировки коллекций (например Collections.sort / List.sort) — он стабильный, то есть сохраняет относительный порядок одинаковых имён (важно для дубликатов).

Документировать: «сортирует на месте; для неизменяемого поведения используйте overload, возвращающий копию списка».

Написать альтернативу для неизменяемости/чистоты (опционально, но на проде полезно): метод, возвращающий новый отсортированный List<Student> (не мутирует вход).

Внутри создаёт shallow-copy списка, сортирует его тем же Comparator-ом и возвращает копию.

Это даёт гибкость и соответствует принципам единой ответственности у вызывающих компонентов.

Покрыть поведение тестами и документировать контракт.

Юнит-тесты: случаи с одинаковыми именами (проверка стабильности), с null-именами, с разными локалями/регистрами, и проверка, что метод сортирует на месте / возвращает копию (в зависимости от варианта).

В javadoc укажи: «не использует Stream API», «поведение с null», «локаль сравнения», «сложность O(n log n)» и что метод стабильный.

Почему именно так (коротко и по делу)

Comparator + Collator даёт корректную, локалезированную и предсказуемую алфавитную сортировку (в отличие от простого String.compareTo, который игнорирует локаль и может вести себя странно с диакритикой).

Статический Comparator в модели — удобная точка согласия: другие слои (репозиторий, сервис) могут переиспользовать правило сортировки, не создавая дублирования. Если ты строго следуешь SOLID, можно вынести Comparator в StudentComparators / StudentUtils (Single Responsibility) — поэтому я предложил и вариант вынести.

Сортировка на месте (Collections.sort / List.sort) — простая и эффективная (TimSort, стабильная), и удовлетворяет требованию «не использовать stream api». При этом обязательно документировать / предоставить вариант, возвращающий копию, чтобы не ломать ожидаемое поведение вызывающих компонентов.

Явная обработка null и тесты убирают класс ошибок, которые в проде любят подкидывать продакшен-данные.

Юнит-тесты и javadoc — обязательны для ясного контракта и безопасного рефакторинга в будущем.

**Сравнение:** 

В целом оба ассистента дали одинаковые ответы, но описали по-разному немного.
Предложили одинаковые варианты решения, но ChatGpt еще напомнил про тесты.
Не могу выбрать один из них, так как оба дали похожие решения,
но можно использовать их вместе, для того, чтоб получить максимально расширенный ответ.

Добавил "Роль" так как читал про составление промта и рекомендуется задавать роль AI.


#### Промпт 2: Проверка кода

**Код для проверки:**

**Что проверить:**
1. Логические ошибки
2. Соответствие Code Conventions
3. Производительность

**AI-1 ([DeepSeek]):**

1. Логические ошибки
   Критические:

totalRemaining вычисляется неправильно - расчет внутри цикла приводит к некорретному промежуточному значению, так как totalTotal и totalCompleted еще не полностью посчитаны. Нужно вычислять после цикла.

Возможные:

При нулевом массиве выбрасывается исключение, но в требовании метода это не указано. Нужно уточнить требования.

2. Соответствие Code Conventions
   Нарушения:

Имя параметра: mentees - должно быть в единственном числе для массива (mentees → menteeArray или просто mentees если это коллекция)

Имя переменной: totalTotal - нечитаемое имя. Лучше totalLessons или overallLessons

Именование метода: completedLessons() и totalLessons() - нарушение camelCase для геттеров, должно быть getCompletedLessons() и getTotalLessons()

Пробелы в строке результата: В выводе есть пробелы, но их может быть недостаточно для читаемости

Комментарий на русском: Хотя это допустимо в корпоративном коде, обычно пишут на английском

Пустые строки: Не хватает пустых строк для разделения логических блоков

3. Производительность
   Проблемы:

Лишняя переменная index: Можно использовать enhanced for-loop

Лишняя переменная totalRemaining: Можно вычислять непосредственно в return

Многократный вызов геттеров: В текущей реализации каждый геттер вызывается один раз - это нормально

**AI-2 ([ChatGPT]):**

Логические ошибки

Счёт totalRemaining внутри цикла
Сейчас ты каждый раз внутри while пересчитываешь totalRemaining = totalTotal - totalCompleted;. Это корректно, но лишнее: достаточно вычислить один раз после суммирования всех mentee. Так меньше лишних операций и яснее код.

Валидность входного массива
Проверка mentees == null || mentees.length == 0 корректна — исключение выбрасывается.

Накопление totalCompleted и totalTotal
Всё верно, суммирование через += безопасно.

Потенциальный нюанс: если completedLessons() > totalLessons(), может получиться отрицательное totalRemaining. Возможно, стоит добавить защиту или хотя бы документировать, что метод ожидает корректные значения.

Формат возвращаемой строки

В текущей реализации между "из X" и "Осталось" нет запятой или точки с запятой, что может выглядеть слегка слипшимся. Чисто косметически лучше: "Суммарно пройдено: 5 из 10. Осталось: 5".

2️⃣ Соответствие Code Conventions (Java)

Название класса и методов — правильное, ProgressTracker и calculateTotalProgress. ✅

Javadoc — есть, но:

@param mentees array mentee → лучше: @param mentees массив menteе или массив учеников.

@return → лучше: @return строка с суммарным прогрессом группы.

Отступы и форматирование — верно.

Именование переменных — ясное, но можно убрать index и использовать for-each (чистый стиль, читаемость выше):

for (Mentee mentee : mentees) {
totalCompleted += mentee.completedLessons();
totalTotal += mentee.totalLessons();
}


Именование totalRemaining — по стилю ок, но можно объявить ближе к месту использования (после цикла).

Производительность

Сложность O(n) — идеально, перебираем массив один раз.

Лишние вычисления

totalRemaining = totalTotal - totalCompleted внутри цикла → лишняя операция n раз. Можно вынести за цикл.

Использование while vs for-each

for-each чуть эффективнее для читаемости и предотвращает ошибки с индексами, но на уровне JVM различия почти нулевые.

Строка конкатенации через +

Для коротких строк в небольших методах — норм, JVM оптимизирует через StringBuilder. Если планируется вызывать метод для сотен тысяч записей, тогда лучше явно через StringBuilder.
 
Вывод / рекомендации

Перенести вычисление totalRemaining после цикла.

Рассмотреть for-each вместо while — читаемее.

Мелкие правки Javadoc и форматирование возвращаемой строки.

Логика корректна, производительность для массивов обычного размера — достаточная.

**Сравнение:**

В целом оба ассистента дали одинаковые ответы, но описали по-разному немного.
Предложили одинаковые варианты решения, но ChatGpt еще напомнил про тесты.
Не могу выбрать один из них, так как оба дали похожие решения,
но можно использовать их вместе, для того, чтоб получить максимально расширенный ответ.

Итоговый вывод:
Лучше использовать обе модели и находить то, что одна из них могла упустить или не подсветить.



